##Bridge

A bridge creates a network switch between [different](https://wiki.archlinux.org/index.php/Network_bridge) network interfaces.

```bash
ip link add name br0 type bridge
ip link set br0 up
ip link set eth0 up
ip link set eth0 master br0
```

Bridge receives a network interface name and can be refereed same as any other network interface in network commands. The above `ip` commands makes it clear that bridge `br0` is logically in the link layer, in same level as `eth0`. 

Bridge takes over the MAC address of the [first](https://serverfault.com/questions/516366/how-virbr0-nic-is-created) interface connected to the bridge, even if that is removed later on.

```bash
modprobe dummy # creates dummy0 device
ip link set dummy0 address aa:aa:aa:bb:bb:bb # MAC
ip addr add 10.0.0.1/24 dev dummy0

ip link add name br0 type bridge
ip link set br0 up
ip link set dummy0 master br0

ip link set dummy0 nomaster # remove from br0
```

##TUN/TAP Devices

[TUN/TAP](http://backreference.org/2010/03/26/tuntap-interface-tutorial/) are virtual network interfaces intended for network data [produced](http://backreference.org/2010/03/26/tuntap-interface-tutorial/) by software applications. TUN is layer 3 and generates IP frames, whereas TAP is layer 2 and generates Ethernet frames. 

For example, [OpenVPN](https://openvpn.net/) client will create a TUN interface, that is advertised as default route, so that plaintext traffic going through it is encrypted and then forwarded to real gateway:

```bash
$ ip addr | grep tun
6: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100
    inet 10.4.1.197/16 brd 10.4.255.255 scope global tun0

$ route -n | grep tun
0.0.0.0         10.4.0.1        128.0.0.0       UG    0      0        0 tun0
10.4.0.0        0.0.0.0         255.255.0.0     U     0      0        0 tun0
128.0.0.0       10.4.0.1        128.0.0.0       UG    0      0        0 tun0

$ ip route show table all | grep tun
0.0.0.0/1 via 10.4.0.1 dev tun0 
10.4.0.0/16 dev tun0 proto kernel scope link src 10.4.1.197 
128.0.0.0/1 via 10.4.0.1 dev tun0 
broadcast 10.4.0.0 dev tun0 table local proto kernel scope link src 10.4.1.197 
local 10.4.1.197 dev tun0 table local proto kernel scope host src 10.4.1.197 
broadcast 10.4.255.255 dev tun0 table local proto kernel scope link src 10.4.1.197 
fe80::/64 dev tun0 proto kernel metric 256  pref medium
ff00::/8 dev tun0 table local metric 256  pref medium
```

TAP interfaces are normally used by hypervisor software, such as, [libvirt](https://libvirt.org/) as the traffic generated by virtual machines is already in Ethernet level, such as the QEMU/KVM `vnet0` TAP in the example below:

```
$ ip addr
...
4: virbr0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
...
5: virbr0-nic: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000
...
7: vnet0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master virbr0 state UNKNOWN group default qlen 1000
...

$ bridge vlan
port    vlan ids
virbr0   1 PVID Egress Untagged

virbr0-nic   1 PVID Egress Untagged

vnet0    1 PVID Egress Untagged
```

A *bridge is used to group TAP connections and [manage](https://wiki.archlinux.org/index.php/QEMU#Tap_networking_with_QEMU) their network traffic as a single virtual LAN (vlan).

###<ins class='nfooter'><a rel='prev' id='fprev' href='#blog/temp/n.md'>n</a> <a rel='next' id='fnext' href='#blog/2017/2017-06-14-Docker-Machine-On-Windows.md'>Docker Machine On Windows</a></ins>
<ins class='nfooter'><a rel='prev' id='fprev' href='#blog/temp/n.md'>n</a> <a rel='next' id='fnext' href='#blog/2017/2017-06-14-Docker-Machine-On-Windows.md'>Docker Machine On Windows</a></ins>
