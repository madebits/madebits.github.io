#Micro-Libraries

2015-04-15

<!--- tags: architecture -->

##Using the Right Tool for the Right Job: A Metaphor

Any kitchen knife can be used to mince garlic, but a very specific tool has been developed for that - a [garlic presser](http://en.wikipedia.org/wiki/Garlic_press) - or crusher. There are definitively benefits on using the presser. There is no garlic smell on your normal knife (which you can remedy by using a separate knife anyway), there is less effort to get the garlic (thought not as nice sliced as it could  have been done with a normal knife). There are also drawbacks on using a garlic presser. You have to know it exists. You have one and be able to find it when you need it. The crushed garlic may look normal to you, if you have not seen something better, but if you have seen something better, then properly hand minced and sliced garlic is always better. In the end is a matter of style and subjectivity. There is the social effect too. Imagine you are invited for dinner and your host uses or does uses a garlic presser: If you have never used a garlic presser, you will very likely be impressed by seeing one and would like to adopt it too. The host will very likely think you are somehow deprived. If you also use a garlic presser you may have just found a discussion topic on what is best. If you have a disguise for crushed garlic, you may try to convince the host it is not always a good idea to use it. And if you are really up to it, you may even have your own made garlic presser, or at least have thought about that.

##Micro-Libraries as the Right Tool

There are a lot of narrow scope **micro-libraries** in software development share the main property of the garlic presser: You do not really need them and the evidence whether they are useful is contextual. There are some micro-libraries where special domain knowledge is encapsulated, such as, physic engines, or graphics, but most of micro-libraries are implementations of small software patterns, or of common utilities. It is obvious, given the number of micro-libraries that appear each day, that is much easier to collect any sub-set of coding techniques and advertise them as a micro software library with a fancy name, than to invent and market a common tool like the garlic presser. Micro-libraries do have their own advantages. An experienced developer tries to identify both sources of variability and repeatability in software and compensate them with appropriate software models. Micro-libraries help experienced developers model common variability quickly across many projects. For novices, micro-libraries additionally compensate for their inferior design experience.

##Micro-Libraries as Vocabulary

Micro-libraries form a dynamic vocabulary of common pattern implementations and specialized domain utilities. A vocabulary is of use technically if it is both precise and limited in cardinality. Similar to [design patterns](http://en.wikipedia.org/wiki/Design_Patterns) micro-libraries define a dynamic vocabulary that combines design and technology together. Despite there is a much bigger number of micro-libraries than patterns, only a smaller set of them survives to be commonly know. As the software development evolves, so do the commonly used micro-libraries (the vocabulary complexity is self-healing). While it would be hard to clearly communicate with a time-traveler using the micro-library vocabulary you currently know, you can precisely communicate using the micro-library vocabulary with a contemporary peer developer. The developer vocabulary is nowadays shifted towards micro-libraries. Learning of the current dialect of micro-library names is part of the ongoing efforts to remain relevant.

##The 2 cent Implementation for the 1 cent Idea

Developers who continuously think on how to find the best models variability and repeatability in software will find most micro-libraries they encounter as nothing more that names for things they already do take care - but thought were not worth naming. Depending on the area of experience, one can often do better on her own that using a micro-library. It remains open to decide whether the code benefits from using an existing micro-library, creating a new one (given micro means they are relatively easy to recreate), or just modeling the code under same principles. Using a commonly 'named' library help others know what you do, same as people used to argue that appending singleton word in a class name helps to know it is a singleton (you are likely to encounter more classes named singleton in code created in days where patterns were popularized, than nowadays, even thought the number of singletons in modern code could be more). Same as one can mine existing code for patterns, one can mine existing code to find common code that can be generalized and turned into micro-libraries. The better the code base is, the more lucky one can be. No one expects that one can read a design pattern book and start writing good systems, but it is a start. Similarly, no one expects that just because one took the most known micro-libraries of current time-frame the resulting software will be any good. There are always more factors in the play, but it is good start that clearly communicates the intention and promotes reuse.

##Short Liveliness of Micro-Libraries

Common availability of free micro-libraries with acceptable licenses creates also a different approach to software development. Same system could be programmed with same quality using a different set of micro-libraries. A team would go first the normal discussions of finding a common level on what  micro-libraries to use and each team would very likely come with a unique set. The fast changing nature of micro-libraries becomes problematic when it comes to long-term software maintenance. Because of the time-shifting effects the old code speaks a different micro-library vocabulary than the current trend. The changing nature of software libraries was not an issue in classing systems as classic libraries change slowly. In the past one had to discuss what technology to use once in five years or so. Now with micro-libraries taking over almost all programming languages (npm, bower, nuget, etc) the decision what to use has to be reviewed every six months. Long lasting software systems using micro-libraries become faster obsolete and legacy with regard to the technology being even before they reach production. 

##Service Modularization to Rescue

The solution to side-effects of micro-libraries in long running systems is to adapt a system architecture that mimics the nature of micro-libraries - namely a system made of isolated [micro-services](http://martinfowler.com/articles/microservices.html). **Micro-services** are developed, maintained, and fully replaced gradually over time using different sets of micro-libraries. Micro-services architecture is not a panacea, but it is must for current trend of using micro-libraries. A long running system using modern micro-libraries approach has to be a micro-service one. In classical long running systems the technology set to use was important and it defined the systems as it did not change for its lifetime (or changed slowly). In micro-service based systems the technology is less relevant as it can change gradually and painless at every point. Developers of micro-service based systems do not maintain time-shifted technologies, as micro-service nodes can be easy re-programmed and replaced using the latest mode of micro-libraries. Failures and testability of micro-services is local. While any system can benefit from using micro-libraries in short term, it is only micro-service systems that can cope and fully benefit from micro-libraries usage in long term.

##No Free Lunch Regardless of the Kitchen Hardware

Micro-service based systems can be successful and viable only when deployment, monitoring, and replacement of micro-service nodes is fully automated. Technologies like containers help isolate micro-service deployment requirements both in time and space. But isolated container based deployment must be still controlled and configured automatically. Micro-service based systems have thus a higher cost of deployment than classical systems. In classical systems often deployment was not part of development planning and was done manually post development. In a micro-service based system deployment is an important part of system development and one has to start with it and grow the rest of the system on the top of that. The good news is that deployment of micro-service based systems is a product line. Its cost may not be justified for a single system, but common [third-party](http://www.ansible.com/) solutions can be reused lowering the cost.

##Increased Efforts due to Distributed Computing

The way [micro-services](http://en.wikipedia.org/wiki/Microservices) are portrayed here implies they do not share same process memory. In order to use different micro-libraries (or different versions), micro-services have to have isolated memory - this usually means they run on different processes and some form of IPC is needed to keep track of the global system state. The system is therefore more complex compared to a more classical architecture. If micro-service nodes are put in different machines (which is usually the case) then the system becomes also distributed, making it ever harder to handle properly as one has to deal with network issues. Micro-service distributed systems are more expensive and require more planning. On the positive side, micro-service distributed systems are easy to load balance, maintain, and easier to deploy on third-party cloud services, lowering own IT maintenance costs.

<ins class='nfooter'><a id='fprev' href='#blog/2015/2015-04-16-Invoking-Custom-.NET-Plugins.md'>Invoking Custom .NET Plugins</a> <a id='fnext' href='#blog/2015/2015-04-14-Evince-Fit-Keyboard-Shortcuts.md'>Evince Fit Keyboard Shortcuts</a></ins>
