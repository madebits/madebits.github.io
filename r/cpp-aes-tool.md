2008

#AES Encryption (Windows and Linux)

<!--- tags: cpp encryption -->

AES tool is a free command-line tool that encrypts / decrypts one file at a time using a password.

* Written in portable C code. Self contained, uses only standard C library.
* Source code available (GPL). Easy to compile on your own.
* Binaries for Windows and Linux.
* AES 128, 192, 256 bit in CBC mode.

Key generation based on PBKDF1 (PKCS #5 v1.5) with SHA256. AES (FIPS 197), SHA256 (FIPS 180-2) implementations are from http://xyssl.org/.

##Usage

AES tool encrypts / decrypts one file at a time (CBC encryption mode).

* To encrypt:

  ```
  ./aes -i file.txt -o file.bin -p password
  ```

* To decrypt:

  ```
  ./aes -d -i file.bin -o file.txt -p password
  ```

If input (`-i file`) is not specified or `-i -` then `stdin` is used. If output (`-o file`) is not specified or `-o -` then `stdout` is used. If the output file exists it will be overwritten!

The password is specified as string on command-line, which is usually convenient, but it be scan be unsafe. In Bash shell:

1. To skip commands stored in history file (given `aes` needs the password in command-line) use a **space** before the command (check bash `HISTIGNORE` documentation for more details). E.g. (note space after $ prompt): 

   ```
   $ ./aes -i file.txt -o file.bin -p password
   ```

1. If you like to type in the password in Bash shell use:
 ```
 read -p "Password: " -s pass && ./aes -i file.txt -o file.bin -p "$pass"
 read -s pass && ./aes -d -i file.bin -o file.txt -p "$pass"
 ```

##Using Pipes

`aes` tool supports reading input from stdin and writing to stdout. For example, the following command should print "0" on Linux:

```
./aes -p test < test.txt | ./aes -d -p test > test1.txt ; [ -z "$(diff test.txt test1.txt)" ] ; echo $?
```

In a similar way, this command outputs "abc":

```
echo "abc" | ./aes -p "t" | base64 | base64 -d | ./aes -d -p "t"
```

The `base64 | base64 -d` part is not really needed, I put it here to show how you can encrypt to printable text if you ever needed that.

##Advanced Usage

The key `salt` and CBC `IV` are generated by default using C `rand()`. This is weak, but it is fully ok if you encrypt few data once a while to send them securely over Internet (because salt and IV only need to be different, not really random). If you encrypt often a lot of different files then consider appending `-r /dev/urandom` as option on Linux, to read the random data from the specified file, for example:

```
read -s pass && echo "abc" | ./aes -p "$pass" -r /dev/urandom | base64 | base64 -d | ./aes -d -p "$pass"
```

An example using `tar` on Linux to compress a folder `./pictures` follows (you can use same to safely backup your home folder):

* To archive `./pictures` folder compressed and then encrypt it as `data.bin`:

   ```
   tar -cvzpf - ./pictures/ | ./aes -p t -r /dev/urandom -o data.bin
   ```

* To decrypt `data.bin` and then uncompress and unarchive it (as `./pictures`):

   ```
   ./aes -d -p t -i data.bin | tar -zxv
   ```

Some of `aes` options you can use are:

* -p to specify the password. You would normally use a password with more than 20 random numbers letters and special characters. To create a good random password of length 45 you can use for example: ```head -c 45 /dev/urandom | base64``` or ```dd if=/dev/urandom bs=45 count=1 2> /dev/null | base64```.
* -k to specify AES 128, 192, or 256 bit (256 bit is default).
* -r read random data needed for encryption from `/dev/urandom` (default C `rand()` function is used).
* -c now many times we hash the password to obtain the encryption key (see also -a below) (default 1024).
* -h some number - *this is evil (TM)* and it needs some more explanation. Without -h (or -h 0), `aes` tool stores the file as (iv,salt,encrypted data), this is multiple of 8 and the offset of begin of each part is known. If we specify an offset with -h we store that much random data first in file (random,iv,salt,encrypted data), so the file length is no more necessary a multiple of 8, and the offsets of the parts are not directly known (see also -a below) (default is -h 0).
* -a [level] is an automatic shortcut for -c and -h (default level for -a is 5). When using -a, then -c, -h are ignored and their values are auto calculated from password based on the formulas shown next, where `passwordSum` is the sum of all password characters as an integer (and `**` is math power):

 ```
 -c ( ( 10 ** level ) + ( level * ( passwordSum % 1024 ) ) )
 -h ( passwordSum % 512 + 1 )
 ```
 To see the actual -c, -h values used when specifying -a use the -v option (verbose). If you specify -a on encrypt, you have to specify it also on decrypt (using same level value). Using a level value bigger than `-a 6` is too slow in practice.

The -p, -k, -a, -c, -h options must specified **same** during decrypt, otherwise cannot access your data.

It is possible to encrypt same data more than once in a chain:

```
echo "abc" | ./aes -p p1 -k 256 -a | ./aes -p p2 -k 128 -a | ./aes -d -p p2 -k 128 -a | ./aes -d -p p1 -k 256 -a
```

We first encrypt twice with password `p1` and then `p2` with different AES key sizes (-k); and then we decrypt (`-d`) the pipe result twice with same data in reverse. The output is `abc`. Encrypting more that once is safer (but slower).

Use `aes -?` for more help.

