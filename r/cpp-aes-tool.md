2008

#AES Encryption (Windows and Linux)

<!--- tags: cpp encryption -->

AES tool is a free command-line tool that encrypts / decrypts one file at a time using a password.

* Written in portable C code. Self contained, uses only standard C library.
* Source code available (GPL). Easy to compile on your own.
* Binaries for Windows and Linux.
* AES 128, 192, 256 bit in CBC mode.

Key generation based on PBKDF2 (or PBKDF1 (PKCS #5 v1.5)) with SHA256. AES (FIPS 197), SHA256 (FIPS 180-2) implementations are from http://xyssl.org/.

##Usage

AES tool encrypts / decrypts one file at a time (CBC encryption mode).

* To encrypt:

  ```bash
  ./aes -i file.txt -o file.bin -p password
  ```

* To decrypt:

  ```bash
  ./aes -d -i file.bin -o file.txt -p password
  ```

If input (`-i file`) is not specified or `-i -` then `stdin` is used. If output (`-o file`) is not specified or `-o -` then `stdout` is used. If the output file exists it will be overwritten! `-m` activates PBKDF1, if not set PBKDF2 is used.

The password is specified as string on command-line via `-p`, which is usually convenient, but it be can be unsafe, or via a file using `-f` (reads at most 256 bytes of first line). In Bash shell:

1. To skip commands stored in history file (if you specify the password in command-line) use a **space** before the command (check bash `HISTIGNORE` documentation for more details). E.g. (note space after $ prompt): 

   ```bash
   $ ./aes -i file.txt -o file.bin -p password
   ```
   
   Or to read password from a file use:

   ```bash
   ./aes -i file.txt -o file.bin -f passwordFile
   ./aes -i file.txt -o file.bin -f <(echo -n "password")
   ```

1. If you like to type in the password in Bash shell use:
 ```bash
 read -p "Password: " -s pass && ./aes -i file.txt -o file.bin -f <(echo -n "$pass")
 read -s pass && ./aes -d -i file.bin -o file.txt -f <(echo -n "$pass")
 ```

##Using Pipes

`aes` tool supports reading input from stdin and writing to stdout. For example, the following command should print "0" on Linux:

```
./aes -p test < test.txt | ./aes -d -p test > test1.txt ; [ -z "$(diff test.txt test1.txt)" ] ; echo $?
```

In a similar way, this command outputs "abc":

```bash
echo "abc" | ./aes -p "t" | base64 | base64 -d | ./aes -d -p "t"

read -s pass && echo abc | aes -p $pass | aes -d -p $pass
```

The `base64 | base64 -d` part is not really needed, I put it here to show how you can encrypt to printable text if you ever needed that.

##Advanced Usage

The key `salt` and CBC `IV` are generated by default using C `rand()`. This is weak, but it is fully ok if you encrypt few data once a while to send them securely over Internet (because salt and IV only need to be different, not really random). If you encrypt often a lot of different files then consider appending `-r /dev/urandom` as default option on Linux, to read the random data from the specified file, for example:

```bash
read -s pass && echo "abc" | ./aes -p "$pass" -r /dev/urandom | base64 | base64 -d | ./aes -d -p "$pass"
```

An example using `tar` on Linux to compress a folder `./pictures` follows (you can use same to safely backup your home folder):

* To archive `./pictures` folder compressed and then encrypt it as `data.bin`:

   ```bash
   tar -cvzpf - ./pictures/ | ./aes -p t -r /dev/urandom -o data.bin
   ```

* To decrypt `data.bin` and then uncompress and unarchive it (as `./pictures`):

   ```bash
   ./aes -d -p t -i data.bin | tar -zxv
   ```

Some of `aes` options you can use are:

* -p to specify the password. You would normally use a password with more than 20 random numbers letters and special characters. To create a good random password of length 45 you can use for example: ```head -c 45 /dev/urandom | base64``` or ```dd if=/dev/urandom bs=45 count=1 2> /dev/null | base64```.
* -k to specify AES 128, 192, or 256 bit (256 bit is default).
* -r read random data needed for encryption from `/dev/urandom` (default C `rand()` function is used if not found).
* -c now many times we hash the password to obtain the encryption key (see also -a below) (default 500000).
* -m to use PBKDF2 for -c (default is PBKDF1).
* -a use non-authenticated encryption, by default authenticated encryption is used 

The -p, -k, -a, -c options must specified **same** during decrypt, otherwise cannot access your data.

It is possible to encrypt same data more than once in a chain:

```bash
echo "abc" | ./aes -p p1 -k 256 | ./aes -p p2 -k 128 | ./aes -d -p p2 -k 128 | ./aes -d -p p1 -k 256
```

We first encrypt twice with password `p1` and then `p2` with different AES key sizes (-k); and then we decrypt (`-d`) the pipe result twice with same data in reverse. The output is `abc`. Encrypting more that once is safer (but slower).

Use `aes -?` for more help.

